import { Model } from "./types";

export const models: Model[] = [
  // ─── Sources ───────────────────────────────────────────────────────────────
  {
    id: "model-src-orders",
    name: "src_orders",
    schema: "raw",
    database: "analytics",
    materialization: "view",
    description:
      "Raw orders table imported from the Jaffle Shop production database. Each row represents a single order placed by a customer.",
    tags: ["source", "raw"],
    columns: [
      { name: "id", type: "integer", description: "Primary key — unique order identifier.", tests: ["unique", "not_null"] },
      { name: "user_id", type: "integer", description: "Foreign key to the customers table.", tests: ["not_null", "relationships"] },
      { name: "order_date", type: "date", description: "Date the order was placed.", tests: ["not_null"] },
      { name: "status", type: "varchar", description: "Order status: placed, shipped, completed, return_pending, or returned.", tests: ["accepted_values"] },
    ],
    sql: `-- source defined in sources.yml\nselect * from {{ source('jaffle_shop', 'orders') }}`,
    dependsOn: [],
    referencedBy: ["model-stg-orders"],
    testsPassing: 5,
    testsFailing: 0,
  },
  {
    id: "model-src-customers",
    name: "src_customers",
    schema: "raw",
    database: "analytics",
    materialization: "view",
    description:
      "Raw customers table from the Jaffle Shop production database. Each row represents one registered customer.",
    tags: ["source", "raw"],
    columns: [
      { name: "id", type: "integer", description: "Primary key — unique customer identifier.", tests: ["unique", "not_null"] },
      { name: "first_name", type: "varchar", description: "Customer first name.", tests: [] },
      { name: "last_name", type: "varchar", description: "Customer last name.", tests: [] },
    ],
    sql: `-- source defined in sources.yml\nselect * from {{ source('jaffle_shop', 'customers') }}`,
    dependsOn: [],
    referencedBy: ["model-stg-customers"],
    testsPassing: 2,
    testsFailing: 0,
  },
  {
    id: "model-src-payments",
    name: "src_payments",
    schema: "raw",
    database: "analytics",
    materialization: "view",
    description:
      "Raw payments table from the Stripe integration. Each row represents a single payment attempt against an order.",
    tags: ["source", "raw", "stripe"],
    columns: [
      { name: "id", type: "integer", description: "Primary key — unique payment identifier.", tests: ["unique", "not_null"] },
      { name: "order_id", type: "integer", description: "Foreign key to the orders table.", tests: ["not_null", "relationships"] },
      { name: "payment_method", type: "varchar", description: "Payment method used: credit_card, coupon, bank_transfer, or gift_card.", tests: ["accepted_values"] },
      { name: "amount", type: "integer", description: "Amount of the payment in cents.", tests: ["not_null"] },
    ],
    sql: `-- source defined in sources.yml\nselect * from {{ source('stripe', 'payments') }}`,
    dependsOn: [],
    referencedBy: ["model-stg-payments"],
    testsPassing: 5,
    testsFailing: 0,
  },
  {
    id: "model-src-products",
    name: "src_products",
    schema: "raw",
    database: "analytics",
    materialization: "view",
    description:
      "Raw products table from the Jaffle Shop product catalog. Each row represents one product available for sale.",
    tags: ["source", "raw"],
    columns: [
      { name: "id", type: "integer", description: "Primary key — unique product identifier.", tests: ["unique", "not_null"] },
      { name: "name", type: "varchar", description: "Display name of the product.", tests: ["not_null"] },
      { name: "category", type: "varchar", description: "Product category: beverage, food, or merch.", tests: ["accepted_values"] },
      { name: "price", type: "numeric", description: "Unit price in USD.", tests: ["not_null"] },
    ],
    sql: `-- source defined in sources.yml\nselect * from {{ source('jaffle_shop', 'products') }}`,
    dependsOn: [],
    referencedBy: ["model-stg-products"],
    testsPassing: 5,
    testsFailing: 0,
  },

  // ─── Staging ───────────────────────────────────────────────────────────────
  {
    id: "model-stg-orders",
    name: "stg_orders",
    schema: "staging",
    database: "analytics",
    materialization: "view",
    description:
      "Cleaned orders from the raw source. Column names are standardized, types are cast, and invalid records are filtered.",
    tags: ["staging"],
    columns: [
      { name: "order_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "customer_id", type: "integer", description: "Foreign key to stg_customers.", tests: ["not_null"] },
      { name: "order_date", type: "date", description: "Date the order was placed (UTC).", tests: ["not_null"] },
      { name: "status", type: "varchar", description: "Standardized order status.", tests: ["accepted_values"] },
    ],
    sql: `with source as (\n    select * from {{ ref('src_orders') }}\n),\n\nrenamed as (\n    select\n        id as order_id,\n        user_id as customer_id,\n        order_date,\n        status\n    from source\n)\n\nselect * from renamed`,
    dependsOn: ["model-src-orders"],
    referencedBy: ["model-int-order-payments", "model-int-customer-orders", "model-fct-orders"],
    testsPassing: 4,
    testsFailing: 0,
  },
  {
    id: "model-stg-customers",
    name: "stg_customers",
    schema: "staging",
    database: "analytics",
    materialization: "view",
    description:
      "Cleaned customers from the raw source with standardized column names and a generated full_name field.",
    tags: ["staging"],
    columns: [
      { name: "customer_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "first_name", type: "varchar", description: "Customer first name.", tests: [] },
      { name: "last_name", type: "varchar", description: "Customer last name.", tests: [] },
      { name: "full_name", type: "varchar", description: "Concatenated first and last name.", tests: ["not_null"] },
    ],
    sql: `with source as (\n    select * from {{ ref('src_customers') }}\n),\n\nrenamed as (\n    select\n        id as customer_id,\n        first_name,\n        last_name,\n        first_name || ' ' || last_name as full_name\n    from source\n)\n\nselect * from renamed`,
    dependsOn: ["model-src-customers"],
    referencedBy: ["model-int-customer-orders", "model-dim-customers"],
    testsPassing: 2,
    testsFailing: 0,
  },
  {
    id: "model-stg-payments",
    name: "stg_payments",
    schema: "staging",
    database: "analytics",
    materialization: "view",
    description:
      "Cleaned payments with amount converted from cents to dollars and standardized column naming.",
    tags: ["staging", "stripe"],
    columns: [
      { name: "payment_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "order_id", type: "integer", description: "Foreign key to stg_orders.", tests: ["not_null"] },
      { name: "payment_method", type: "varchar", description: "Method of payment.", tests: ["accepted_values"] },
      { name: "amount", type: "numeric", description: "Payment amount in dollars (converted from cents).", tests: ["not_null"] },
    ],
    sql: `with source as (\n    select * from {{ ref('src_payments') }}\n),\n\nrenamed as (\n    select\n        id as payment_id,\n        order_id,\n        payment_method,\n        amount / 100.0 as amount\n    from source\n)\n\nselect * from renamed`,
    dependsOn: ["model-src-payments"],
    referencedBy: ["model-int-order-payments", "model-fct-revenue"],
    testsPassing: 4,
    testsFailing: 0,
  },
  {
    id: "model-stg-products",
    name: "stg_products",
    schema: "staging",
    database: "analytics",
    materialization: "view",
    description:
      "Cleaned products table with standardized column names and category normalization.",
    tags: ["staging"],
    columns: [
      { name: "product_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "product_name", type: "varchar", description: "Display name of the product.", tests: ["not_null"] },
      { name: "category", type: "varchar", description: "Normalized product category.", tests: ["accepted_values"] },
      { name: "price", type: "numeric", description: "Unit price in USD.", tests: ["not_null"] },
    ],
    sql: `with source as (\n    select * from {{ ref('src_products') }}\n),\n\nrenamed as (\n    select\n        id as product_id,\n        name as product_name,\n        lower(trim(category)) as category,\n        price\n    from source\n)\n\nselect * from renamed`,
    dependsOn: ["model-src-products"],
    referencedBy: ["model-dim-products", "model-fct-orders"],
    testsPassing: 4,
    testsFailing: 0,
  },

  // ─── Intermediate ──────────────────────────────────────────────────────────
  {
    id: "model-int-order-payments",
    name: "int_order_payments",
    schema: "intermediate",
    database: "analytics",
    materialization: "ephemeral",
    description:
      "Aggregates payments to the order grain. Produces one row per order with the total payment amount and a comma-separated list of payment methods used.",
    tags: ["intermediate", "finance"],
    columns: [
      { name: "order_id", type: "integer", description: "Primary key — one row per order.", tests: ["unique", "not_null"] },
      { name: "total_amount", type: "numeric", description: "Sum of all successful payments for the order.", tests: ["not_null"] },
      { name: "payment_methods", type: "varchar", description: "Comma-separated list of distinct payment methods.", tests: [] },
    ],
    sql: `with payments as (\n    select * from {{ ref('stg_payments') }}\n),\n\norders as (\n    select * from {{ ref('stg_orders') }}\n),\n\norder_payments as (\n    select\n        orders.order_id,\n        sum(payments.amount) as total_amount,\n        string_agg(distinct payments.payment_method, ', ') as payment_methods\n    from orders\n    left join payments on orders.order_id = payments.order_id\n    group by 1\n)\n\nselect * from order_payments`,
    dependsOn: ["model-stg-orders", "model-stg-payments"],
    referencedBy: ["model-fct-orders", "model-fct-revenue"],
    testsPassing: 2,
    testsFailing: 0,
  },
  {
    id: "model-int-customer-orders",
    name: "int_customer_orders",
    schema: "intermediate",
    database: "analytics",
    materialization: "ephemeral",
    description:
      "Aggregates orders to the customer grain. Computes first and most recent order dates and total order count per customer.",
    tags: ["intermediate"],
    columns: [
      { name: "customer_id", type: "integer", description: "Primary key — one row per customer.", tests: ["unique", "not_null"] },
      { name: "first_order_date", type: "date", description: "Date of the customer's first order.", tests: [] },
      { name: "most_recent_order_date", type: "date", description: "Date of the customer's most recent order.", tests: [] },
      { name: "number_of_orders", type: "integer", description: "Lifetime count of orders placed.", tests: [] },
    ],
    sql: `with orders as (\n    select * from {{ ref('stg_orders') }}\n),\n\ncustomers as (\n    select * from {{ ref('stg_customers') }}\n),\n\ncustomer_orders as (\n    select\n        customers.customer_id,\n        min(orders.order_date) as first_order_date,\n        max(orders.order_date) as most_recent_order_date,\n        count(orders.order_id) as number_of_orders\n    from customers\n    left join orders on customers.customer_id = orders.customer_id\n    group by 1\n)\n\nselect * from customer_orders`,
    dependsOn: ["model-stg-orders", "model-stg-customers"],
    referencedBy: ["model-dim-customers"],
    testsPassing: 2,
    testsFailing: 0,
  },

  // ─── Marts — Dimensions ────────────────────────────────────────────────────
  {
    id: "model-dim-customers",
    name: "dim_customers",
    schema: "marts",
    database: "analytics",
    materialization: "table",
    description:
      "Customer dimension table combining profile information with order summary metrics. This is the canonical customer entity used by downstream dashboards and the BI layer.",
    tags: ["marts", "finance"],
    columns: [
      { name: "customer_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "full_name", type: "varchar", description: "Customer full name.", tests: ["not_null"] },
      { name: "first_order_date", type: "date", description: "Date of first order.", tests: [] },
      { name: "most_recent_order_date", type: "date", description: "Date of most recent order.", tests: [] },
      { name: "number_of_orders", type: "integer", description: "Lifetime order count.", tests: [] },
    ],
    sql: `with customers as (\n    select * from {{ ref('stg_customers') }}\n),\n\ncustomer_orders as (\n    select * from {{ ref('int_customer_orders') }}\n),\n\nfinal as (\n    select\n        customers.customer_id,\n        customers.full_name,\n        customer_orders.first_order_date,\n        customer_orders.most_recent_order_date,\n        coalesce(customer_orders.number_of_orders, 0) as number_of_orders\n    from customers\n    left join customer_orders using (customer_id)\n)\n\nselect * from final`,
    dependsOn: ["model-stg-customers", "model-int-customer-orders"],
    referencedBy: ["model-metricstore-daily-revenue"],
    testsPassing: 2,
    testsFailing: 0,
  },
  {
    id: "model-dim-products",
    name: "dim_products",
    schema: "marts",
    database: "analytics",
    materialization: "table",
    description:
      "Product dimension table providing the canonical view of the product catalog with enriched category labels.",
    tags: ["marts", "product"],
    columns: [
      { name: "product_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "product_name", type: "varchar", description: "Display name of the product.", tests: ["not_null"] },
      { name: "category", type: "varchar", description: "Product category.", tests: ["accepted_values"] },
      { name: "price", type: "numeric", description: "Current unit price in USD.", tests: ["not_null"] },
    ],
    sql: `with products as (\n    select * from {{ ref('stg_products') }}\n),\n\nfinal as (\n    select\n        product_id,\n        product_name,\n        category,\n        price\n    from products\n)\n\nselect * from final`,
    dependsOn: ["model-stg-products"],
    referencedBy: ["model-fct-orders"],
    testsPassing: 4,
    testsFailing: 0,
  },

  // ─── Marts — Facts ─────────────────────────────────────────────────────────
  {
    id: "model-fct-orders",
    name: "fct_orders",
    schema: "marts",
    database: "analytics",
    materialization: "incremental",
    description:
      "Fact table containing one row per order with denormalized payment totals and product information. Incrementally loaded based on order_date.",
    tags: ["marts", "finance", "incremental"],
    columns: [
      { name: "order_id", type: "integer", description: "Primary key.", tests: ["unique", "not_null"] },
      { name: "customer_id", type: "integer", description: "Foreign key to dim_customers.", tests: ["not_null", "relationships"] },
      { name: "order_date", type: "date", description: "Date the order was placed.", tests: ["not_null"] },
      { name: "status", type: "varchar", description: "Current order status.", tests: ["accepted_values"] },
      { name: "total_amount", type: "numeric", description: "Total payment amount in USD.", tests: [] },
      { name: "payment_methods", type: "varchar", description: "Payment methods used.", tests: [] },
    ],
    sql: `{{\n  config(\n    materialized='incremental',\n    unique_key='order_id'\n  )\n}}\n\nwith orders as (\n    select * from {{ ref('stg_orders') }}\n),\n\norder_payments as (\n    select * from {{ ref('int_order_payments') }}\n),\n\nfinal as (\n    select\n        orders.order_id,\n        orders.customer_id,\n        orders.order_date,\n        orders.status,\n        order_payments.total_amount,\n        order_payments.payment_methods\n    from orders\n    left join order_payments using (order_id)\n    {% if is_incremental() %}\n      where orders.order_date >= (select max(order_date) from {{ this }})\n    {% endif %}\n)\n\nselect * from final`,
    dependsOn: ["model-stg-orders", "model-int-order-payments", "model-stg-products", "model-dim-products"],
    referencedBy: ["model-metricstore-daily-revenue"],
    testsPassing: 5,
    testsFailing: 1,
  },
  {
    id: "model-fct-revenue",
    name: "fct_revenue",
    schema: "marts",
    database: "analytics",
    materialization: "incremental",
    description:
      "Revenue fact table aggregated at the order + payment-method grain. Used as the source of truth for all revenue reporting.",
    tags: ["marts", "finance", "incremental"],
    columns: [
      { name: "order_id", type: "integer", description: "Foreign key to fct_orders.", tests: ["not_null"] },
      { name: "payment_method", type: "varchar", description: "Payment method used.", tests: ["not_null"] },
      { name: "amount", type: "numeric", description: "Revenue amount in USD.", tests: ["not_null"] },
      { name: "order_date", type: "date", description: "Date of the order.", tests: ["not_null"] },
    ],
    sql: `{{\n  config(\n    materialized='incremental',\n    unique_key=['order_id', 'payment_method']\n  )\n}}\n\nwith payments as (\n    select * from {{ ref('stg_payments') }}\n),\n\norder_payments as (\n    select * from {{ ref('int_order_payments') }}\n),\n\nfinal as (\n    select\n        payments.order_id,\n        payments.payment_method,\n        payments.amount,\n        order_payments.total_amount as order_total\n    from payments\n    left join order_payments using (order_id)\n    {% if is_incremental() %}\n      where payments.order_id in (\n        select order_id from order_payments\n        where order_id > (select max(order_id) from {{ this }})\n      )\n    {% endif %}\n)\n\nselect * from final`,
    dependsOn: ["model-stg-payments", "model-int-order-payments"],
    referencedBy: ["model-metricstore-daily-revenue"],
    testsPassing: 4,
    testsFailing: 0,
  },

  // ─── Metrics ───────────────────────────────────────────────────────────────
  {
    id: "model-metricstore-daily-revenue",
    name: "metricstore_daily_revenue",
    schema: "metrics",
    database: "analytics",
    materialization: "table",
    description:
      "Daily revenue metric store combining order and revenue facts with customer dimensions. Powers the executive KPI dashboard and Slack alerts.",
    tags: ["metrics", "finance", "daily"],
    columns: [
      { name: "date_day", type: "date", description: "Calendar date.", tests: ["unique", "not_null"] },
      { name: "total_revenue", type: "numeric", description: "Total revenue for the day in USD.", tests: ["not_null"] },
      { name: "order_count", type: "integer", description: "Number of orders placed.", tests: ["not_null"] },
      { name: "unique_customers", type: "integer", description: "Distinct customers who placed orders.", tests: [] },
    ],
    sql: `with orders as (\n    select * from {{ ref('fct_orders') }}\n),\n\nrevenue as (\n    select * from {{ ref('fct_revenue') }}\n),\n\ncustomers as (\n    select * from {{ ref('dim_customers') }}\n),\n\ndaily as (\n    select\n        orders.order_date as date_day,\n        sum(revenue.amount) as total_revenue,\n        count(distinct orders.order_id) as order_count,\n        count(distinct orders.customer_id) as unique_customers\n    from orders\n    left join revenue on orders.order_id = revenue.order_id\n    left join customers on orders.customer_id = customers.customer_id\n    group by 1\n)\n\nselect * from daily`,
    dependsOn: ["model-fct-orders", "model-fct-revenue", "model-dim-customers"],
    referencedBy: [],
    testsPassing: 3,
    testsFailing: 0,
  },
];
